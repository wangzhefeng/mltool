---
title: "XGBoost with parameter tuning"
author: "tinker wang"
date: "2018年7月22日"
output:
  html_document:
    number_sections: true
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#摘要


#介绍

<!-- <center><img src='https://storage.googleapis.com/kaggle-competitions/kaggle/5407/media/housesbanner.png'></center> -->

#导入和探索数据

##导入需要的R包和读取数据

```{r, message = FALSE, warning = FALSE}
library(readr)
library(knitr)
library(ggplot2)
library(dplyr)
library(corrplot)
library(caret)
library(gridExtra)
library(scales)
library(Rmisc)
library(ggrepel)
library(randomForest)
library(psych)
library(xgboost)
```


```{r, message = FALSE}
train = readr::read_csv(file = "E:/DataScience/kaggle_proj/pro_HousePrice/data/train.csv", col_names = TRUE)
test = readr::read_csv(file = "E:/DataScience/kaggle_proj/pro_HousePrice/data/test.csv", col_names = TRUE)
```

```{r, eval = FALSE}
con = DBI::dbConnect(odbc::odbc(),
                     Driver = "SQL Server",
                     Server = "WANGZF-PC",
                     Database = "tinker",
                     UID = "tinker.wang",
                     # UID = rstudioapi::askForPassword("Database User"),
                     PWD = "alvin123",
                     # PWD = rstudioapi::askForPassword("SQL Server Database password"),
                     Port = 1433)
```

##数据维度以及结构


```{r}
dim(train)
str(train[, c(1:10, 81)])
```

```{r}
train$Id = NULL
test_labels = test$Id
test$Id = NULL
test$SalePrice = NA
all =  rbind(train, test)
dim(all)
head(all)
dim(train)
dim(test)
```


#对一些重要的变量进行探索性分析

##响应变量SalePrice的探索性分析

```{r}
sapply(all %>% select(SalePrice), function(x) sum(is.na(x)))
```

```{r}
ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = SalePrice)) +
    geom_histogram(binwidth = 10000) +
    scale_x_continuous(breaks = seq(0, 800000, 100000), labels = comma) +
    theme_light()

summary(all$SalePrice)
describe(all$SalePrice)
```

##自变量的探索性分析

###自变量和SalePrice的相关关系

```{r}
numericVars = which(sapply(all, is.numeric))
numericVarNames = names(numericVars)
numericVarNames
cat("数值型变量的个数是:", length(numericVars))
```

```{r}
all_numVar = all[, numericVars]
cor_numVar = cor(all_numVar, use = "pairwise.complete.obs")
cor_sorted = as.matrix(sort(cor_numVar[, "SalePrice"], decreasing = TRUE))

CorHigh = names(which(apply(cor_sorted, 1, function(x) {abs(x) > 0.5})))
cor_numVar = cor_numVar[CorHigh, CorHigh]
corrplot.mixed(cor_numVar, tl.col = "black", tl.pos = "lt")
```

###分析OverallQual和SalePrice的相关关系

```{r}
ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = factor(OverallQual), y = SalePrice, colour = factor(OverallQual))) +
    geom_boxplot() +
    xlab("Overall Qual") +
    ylab("Sale Price") +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma)
```


###分析GrLivArea和SalePrice的相关关系


```{r}
ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = GrLivArea, y = SalePrice)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, aes(group = 1)) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), label = comma) +
    geom_text_repel(mapping = aes(label = ifelse(all$GrLivArea[!is.na(all$SalePrice)] > 4500, rownames(all), "")))

all[c(524, 1299), c("SalePrice", "GrLivArea", "OverallQual")]
```


#Missing Values, label encoding, and factorizing variables

##缺失值检查

```{r}
NAcol <- which(colSums(is.na(all)) > 0)
sort(colSums(sapply(all[NAcol], is.na)), decreasing = TRUE)
cat('There are', length(NAcol), 'columns with missing values')
```

##缺失值检查及填充 {.tabset}

###Pool相关的变量

* **检查Pool相关的变量缺失情况**

```{r}
PoolNaCols = all %>%
    select(starts_with("Pool")) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
PoolNaCols
```


**Pool Quality 和 PoolArea**

PoolQC变量是缺失值最多的变量，变量的观测值含义如下：

PoolQC: 泳池质量
		
       Ex	Excellent
       Gd	Good
       TA	Average/Typical
       Fa	Fair
       NA	No Pool

* 很明显PoolQC为缺失值代表着这些房子没有泳池，因此，将这些缺失值填充为"None"，并且可以看到只有很少的房子是带有游泳池的，这很符合现实情况：

```{r}
all$PoolQC[is.na(all$PoolQC)] = 'None'
```

* 泳池的质量应该是一个有序的类别型变量，因此这里将该变量重编码为有序类别变量：

```{r, message = FALSE}
Qualities = c('None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)
all$PoolQC = as.integer(revalue(all$PoolQC, Qualities))
table(all$PoolQC)
```

PoolArea: 泳池面积

* 和PoolQC相关的一个泳池变量为PoolArea，泳池的面积明显也直接影响着泳池质量评分的高低，在数据中可以看到有3个明显的观测值的泳池面积不为零，而泳池的质量却为零，明显这是不合理的，因为PoolQC=0代表着该房子没有泳池，因此根据PoolArea的大小和OverallQual的值给这三个房子的PoolQC进行合理的评分：

```{r}
all[all$PoolArea > 0 & all$PoolQC == 0, c('PoolArea', 'PoolQC', 'OverallQual')]
all$PoolQC[2421] = 2
all$PoolQC[2504] = 3
all$PoolQC[2600] = 2
```

* 填充后的PoolQC变量：

```{r}
table(all$PoolQC)
```



**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Miscellaneous Feature



       Elev	Elevator(电梯)
       Gar2	2nd Garage(车库) (if not described in garage section)
       Othr	Other
       Shed	Shed(棚子) (over 100 SF)
       TenC	Tennis Court(网球场)
       NA	None

```{r}
all$MiscFeature[is.na(all$MiscFeature)] = "None"
all$MiscFeature = all$MiscFeature %>% as.factor()
table(all$MiscFeature)
```

```{r}
ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = MiscFeature, y = SalePrice)) +
    geom_bar(stat = "summary", fun.y = "median", mapping = aes(fill = MiscFeature)) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma) +
    geom_label(stat = "count", mapping = aes(label = ..count.., y = ..count..))
```




**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Alley

**Type of alley access to property**

在Alley变量中有2721个缺失值. 这个变量不是有序变量，所以Alley转换为因子类型变量：

       Grvl	Gravel(碎石)
       Pave	Paved(铺砌)
       NA 	No alley access

```{r}
all$Alley[is.na(all$Alley)] = "None"
all$Alley = all$Alley %>% 
    as.factor()

ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = Alley, y = SalePrice)) +
    geom_bar(stat = "summary", fun.y = "median", mapping = aes(fill = Alley)) +
    scale_y_continuous(breaks = seq(0, 200000, by = 50000), label = comma)
```

```{r}
table(all$Alley)
```


**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Fence

**Fence quality**

Fence中有2348个缺失值. 并且该变量似乎是有序类别型变量:

       GdPrv	Good Privacy
       MnPrv	Minimum Privacy
       GdWo	    Good Wood
       MnWw	    Minimum Wood/Wire
       NA	    No Fence

```{r}
all$Fence[is.na(all$Fence)] = "None"
all$Fence %>% table()
```


```{r}
# detach("package:plyr", unload = TRUE)
# conflicts()
all[!is.na(all$SalePrice), ] %>%
    group_by(as.factor(Fence)) %>%
    dplyr::summarise(medians = median(SalePrice), counts = n())
```

由于不同的篱笆质量下，房价中位数没有太大的差别，即对于房价来说，没有好的篱笆和坏的篱笆之分，因此，这里认为Fence不是有序类别型变量，只是普通的因子型变量：

```{r}
all$Fence = as.factor(all$Fence)
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Fireplace(壁炉)

**FireplaceQu(壁炉质量)和Fireplaces(壁炉质量)**

在FireplaceQu中有1420个缺失值，Fireplaces没有缺失值.

**FireplaceQu**

The number of NAs in FireplaceQu matches the number of houses with 0 fireplaces. This means that I can safely replace the NAs in FireplaceQu with 'no fireplace'. The values are ordinal, and I can use the Qualities vector that I have already created for the Pool Quality. Values:

FireplaceQu中的缺失值数量正好是Fireplaces=0的观测值数量，因此，可以将FireplaceQu中的缺失观测填充为"None"，并且FireplaceQu是有序类别型变量，根据PoolQC中的编码向量Qualities将FireplaceQu重新编码为有序因子:

       Ex	Excellent - Exceptional Masonry Fireplace
       Gd	Good - Masonry Fireplace in main level
       TA	Average - Prefabricated Fireplace in main living area or Masonry Fireplace in basement
       Fa	Fair - Prefabricated Fireplace in basement
       Po	Poor - Ben Franklin Stove
       NA	No Fireplace

```{r}
all$FireplaceQu[is.na(all$FireplaceQu)] = "None"
all$FireplaceQu = as.integer(revalue(all$FireplaceQu, Qualities))
all$FireplaceQu %>% table()
```

**Fireplaces**

Fireplaces是一个整数型变量，且没有缺失值：

```{r}
all$Fireplaces %>% table()
all$Fireplaces %>% table() %>% sum()
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Lot variables

* LotForntage: 有486个缺失值
* LotShape：无缺失值
* LotConfig：无缺失值

**LotFrontage: Linear feet of street connected to property**

LotFrontage与Neighborhood有很强的相关性, 因此对LotFrontage中缺失的观测值在相应的Neighborhood下的中位数进行填充:

```{r}
ggplot(data = all[!is.na(all$LotFrontage),], aes(x = as.factor(Neighborhood), y = LotFrontage)) +
        geom_bar(stat = 'summary', fun.y = "median") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    xlab("Neighborhood")
```

```{r}
med = all %>% 
    group_by(Nei = as.factor(Neighborhood)) %>%
    dplyr::summarise(medians = median(LotFrontage, na.rm = TRUE))
all = all %>% mutate(id = rownames(all))
missing = all %>% 
    select(c(id, LotFrontage, Neighborhood)) %>%
    filter(is.na(LotFrontage)) %>%
    left_join(med, by = c("Neighborhood" = "Nei"))

for(i in  missing$id) {
    all$LotFrontage[all$id == i] = missing$medians[missing$id == i]
}
all = all %>% select(-id)
# for (i in 1:nrow(all)){
#         if(is.na(all$LotFrontage[i])){
#                all$LotFrontage[i] = as.integer(median(all$LotFrontage[all$Neighborhood == all$Neighborhood[i]], na.rm = TRUE)) 
#         }
# }
```

```{r}
all %>%
    filter(is.na(LotFrontage))
```

**LotShape: General shape of property**

没有缺失值，并且是一个有序类别型变量：

       Reg	Regular	
       IR1	Slightly irregular
       IR2	Moderately Irregular
       IR3	Irregular

```{r}
all$LotShape<-as.integer(revalue(all$LotShape, c('IR3' = 0, 'IR2' = 1, 'IR1' = 2, 'Reg' = 3)))
table(all$LotShape)
sum(table(all$LotShape))
```

**LotConfig: Lot configuration**

没有缺失值，且不是有序变量：

       Inside	Inside lot
       Corner	Corner lot
       CulDSac	Cul-de-sac
       FR2	Frontage on 2 sides of property
       FR3	Frontage on 3 sides of property
       
```{r}
ggplot(all[!is.na(all$SalePrice), ], aes(x = as.factor(LotConfig), y = SalePrice)) +
    geom_bar(stat = 'summary', fun.y = "median")+
    scale_y_continuous(breaks = seq(0, 800000, by = 100000), labels = comma) +
    geom_label(stat = "count", aes(label = ..count.., y = ..count..))
```

```{r}
all$LotConfig <- as.factor(all$LotConfig)
table(all$LotConfig)
sum(table(all$LotConfig))
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Garage(车库)变量

**有7个和车库有关的变量，变量观测值缺失情况：**


```{r}
GarageNacols = all %>%
    select(starts_with("Garage")) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
GarageNacols
head(all %>% select(starts_with("Garage")))
```

* **GarageYrBlt:**

对于GarageYrBlt，显然应该和YearBuilt变量有相同的值，因为车库基本是在房子建造的时候建的(也有可能是后来在别的地方新建的)：

```{r}
all$GarageYrBlt[is.na(all$GarageYrBlt)] = all$YearBuilt[is.na(all$GarageYrBlt)]
```


对于车库变量中的字符型变量，NA代表着没有车库，现在来分析一下GarageType和其他三个有159个缺失值的变量是否有直接的关系：


```{r}
#check if all 157 NAs are the same observations among the variables with 157/159 NAs
length(which(is.na(all$GarageType) & is.na(all$GarageFinish) & is.na(all$GarageCond) & is.na(all$GarageQual)))

#Find the 2 additional NAs
kable(all[!is.na(all$GarageType) & is.na(all$GarageFinish), c('GarageCars', 'GarageArea', 'GarageType', 'GarageCond', 'GarageQual', 'GarageFinish')])
```


GarageType变量中缺失的157个值在GarageCondition, GarageQuanlity, GarageFinish中也同时都缺失。不同的是第2127和2577个房子，第2127个房子似乎是有车库的，而2577个房子没有车库，所以应该有158个房子没有车库，因此，需要对第2127个房子的其他变量进行填充，这里用每个变量的众数来进行缺失值填充GarageCond, GarageQual和GarageFinish：

```{r}
#Imputing modes.
all$GarageCond[2127] <- names(sort(-table(all$GarageCond)))[1]
all$GarageQual[2127] <- names(sort(-table(all$GarageQual)))[1]
all$GarageFinish[2127] <- names(sort(-table(all$GarageFinish)))[1]

#display "fixed" house
kable(all[2127, c('GarageYrBlt', 'GarageCars', 'GarageArea', 'GarageType', 'GarageCond', 'GarageQual', 'GarageFinish')])
```

现在车库变量的缺失情况是：

```{r}
GarageNacols = all %>%
    select(starts_with("Garage")) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
GarageNacols
```
 

* **GarageCars and GarageArea: 容纳车库的体积和车库的面积** 

这两个变量都只有一个缺失值，都是第2577号房子的缺失值，GarageType是"detached"且其他变量都是缺失，因此，可以判断这个房子没有车库：

```{r}
#fixing 3 values for house 2577
all$GarageCars[2577] <- 0
all$GarageArea[2577] <- 0
all$GarageType[2577] <- NA

#check if NAs of the character variables are now all 158
length(which(is.na(all$GarageType) & is.na(all$GarageFinish) & is.na(all$GarageCond) & is.na(all$GarageQual)))
```

```{r}
GarageNacols = all %>%
    select(starts_with("Garage")) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
GarageNacols
```

现在只剩下四个字符型车库变量有缺失值，并且都同时缺失158个，说明这158个房子就是没有车库，因此将他们都填充为无车库对应的值即可。

* **GarageType: 车库位置**

这个变量明显不是有序变量，因此只需要将其转换为因子型变量：

       2Types	More than one type of garage
       Attchd	Attached to home
       Basment	Basement Garage
       BuiltIn	Built-In (Garage part of house - typically has room above garage)
       CarPort	Car Port
       Detchd	Detached from home
       NA	No Garage

```{r}
all$GarageType[is.na(all$GarageType)] = 'No Garage'
all$GarageType = as.factor(all$GarageType)
table(all$GarageType)
```

**GarageFinish: 车库的内部装饰**

这个变量是有序类别型变量：

       Fin	Finished
       RFn	Rough Finished	
       Unf	Unfinished
       NA	No Garage       

```{r}
all$GarageFinish[is.na(all$GarageFinish)] = 'None'
Finish = c('None' = 0, 'Unf' = 1, 'RFn' = 2, 'Fin' = 3)

all$GarageFinish = as.integer(revalue(all$GarageFinish, Finish))
table(all$GarageFinish)
```

**GarageQual: Garage quality**

有序类别型变量：

       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
       NA	No Garage
       
```{r}
all$GarageQual[is.na(all$GarageQual)] = 'None'
all$GarageQual = as.integer(revalue(all$GarageQual, Qualities))
table(all$GarageQual)
```

**GarageCond: Garage condition**

有序类别型变量：

       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
       NA	No Garage

```{r}
all$GarageCond[is.na(all$GarageCond)] = 'None'
all$GarageCond = as.integer(revalue(all$GarageCond, Qualities))
table(all$GarageCond)
```

```{r}
GarageNacols = all %>%
    select(starts_with("Garage")) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
GarageNacols
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Basement(地下室)变量

**共有11个关于Basement的变量**

```{r}
BasementCols = all %>%
    select(starts_with("Bs"), TotalBsmtSF)
BasementCols
```




```{r}
BasementNacols = all %>%
    select(starts_with("Bs"), TotalBsmtSF) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
BasementNacols
```

* **分析变量缺失的模式：**

```{r}
#check if all 79 NAs are the same observations among the variables with 80+ NAs
length(which(is.na(all$BsmtQual) & is.na(all$BsmtCond) & is.na(all$BsmtExposure) & is.na(all$BsmtFinType1) & is.na(all$BsmtFinType2)))

#Find the additional NAs; BsmtFinType1 is the one with 79 NAs
all[!is.na(all$BsmtFinType1) & (is.na(all$BsmtCond)|is.na(all$BsmtQual)|is.na(all$BsmtExposure)|is.na(all$BsmtFinType2)), c('BsmtQual', 'BsmtCond', 'BsmtExposure', 'BsmtFinType1', 'BsmtFinType2')]
```

> 从上面分析发现的变量缺失模式可以看出，有79个房子的BsmtQual, BsmtCond, BsmtExposure, BsmtFinType1, BsmtFinType2同时缺失，说明这79个房子没有地下室。
> 对其他的几个缺失值，这里先用众数进行填充。

```{r}
#Imputing modes.
all$BsmtFinType2[333] = names(sort(-table(all$BsmtFinType2)))[1]
all$BsmtExposure[c(949, 1488, 2349)] = names(sort(-table(all$BsmtExposure)))[1]
all$BsmtCond[c(2041, 2186, 2525)] = names(sort(-table(all$BsmtCond)))[1]
all$BsmtQual[c(2218, 2219)] = names(sort(-table(all$BsmtQual)))[1]
```


```{r}
BasementNacols = all %>%
    select(starts_with("Bs"), TotalBsmtSF) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
BasementNacols
```

* **对于上面的5个同时缺失的没有地下室的变量，进行填充和重新编码：**

* **BsmtQual: 地下室的高度**

有序类别型变量：

       Ex	Excellent (100+ inches)	
       Gd	Good (90-99 inches)
       TA	Typical (80-89 inches)
       Fa	Fair (70-79 inches)
       Po	Poor (<70 inches
       NA	No Basement

```{r, message=FALSE}
all$BsmtQual[is.na(all$BsmtQual)] = 'None'
all$BsmtQual<-as.integer(revalue(all$BsmtQual, Qualities))
table(all$BsmtQual)
```
		
* **BsmtCond: 地下室的基本请款评分**

有序类别型变量：

       Ex	Excellent
       Gd	Good
       TA	Typical - slight dampness allowed
       Fa	Fair - dampness or some cracking or settling
       Po	Poor - Severe cracking, settling, or wetness
       NA	No Basement

```{r, message=FALSE}
all$BsmtCond[is.na(all$BsmtCond)] = 'None'
all$BsmtCond<-as.integer(revalue(all$BsmtCond, Qualities))
table(all$BsmtCond)
```
	
* **BsmtExposure: Refers to walkout or garden level walls**

有序类别型变量：

       Gd	Good Exposure
       Av	Average Exposure (split levels or foyers typically score average or above)	
       Mn	Mimimum Exposure
       No	No Exposure
       NA	No Basement

```{r}
all$BsmtExposure[is.na(all$BsmtExposure)] = 'None'
Exposure = c('None' = 0, 'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)

all$BsmtExposure = as.integer(revalue(all$BsmtExposure, Exposure))
table(all$BsmtExposure)
```
       
* **BsmtFinType1: Rating of basement finished area**

A variable than can be made ordinal.

       GLQ	Good Living Quarters
       ALQ	Average Living Quarters
       BLQ	Below Average Living Quarters	
       Rec	Average Rec Room
       LwQ	Low Quality
       Unf	Unfinshed
       NA	No Basement
		
```{r}
all$BsmtFinType1[is.na(all$BsmtFinType1)] <- 'None'
FinType <- c('None'=0, 'Unf'=1, 'LwQ'=2, 'Rec'=3, 'BLQ'=4, 'ALQ'=5, 'GLQ'=6)

all$BsmtFinType1<-as.integer(revalue(all$BsmtFinType1, FinType))
table(all$BsmtFinType1)
```

* **BsmtFinType2: Rating of basement finished area (if multiple types)**

有序类别型变量：

       GLQ	Good Living Quarters
       ALQ	Average Living Quarters
       BLQ	Below Average Living Quarters	
       Rec	Average Rec Room
       LwQ	Low Quality
       Unf	Unfinshed
       NA	No Basement

```{r}
all$BsmtFinType2[is.na(all$BsmtFinType2)] = 'None'
FinType <- c('None' = 0, 'Unf' = 1, 'LwQ' = 2, 'Rec' = 3, 'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)

all$BsmtFinType2 = as.integer(revalue(all$BsmtFinType2, FinType))
table(all$BsmtFinType2)
```



```{r}
BasementNacols = all %>%
    select(starts_with("Bs"), TotalBsmtSF) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
BasementNacols
```


* **剩余的只有少数缺失值的变量处理**

```{r}
#display remaining NAs. Using BsmtQual as a reference for the 79 houses without basement agreed upon earlier
all[(is.na(all$BsmtFullBath) | is.na(all$BsmtHalfBath) | is.na(all$BsmtFinSF1) | is.na(all$BsmtFinSF2) | is.na(all$BsmtUnfSF) | is.na(all$TotalBsmtSF)), c('BsmtQual', 'BsmtFullBath', 'BsmtHalfBath', 'BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF', 'TotalBsmtSF')]
```

上面的分析明显说明这些缺失值是由于没有显示完整而导致的，有可能是数据收集的时候造成，下面对他们进行填充：


**BsmtFullBath: Basement full bathrooms**

整数变量.
```{r}
all$BsmtFullBath[is.na(all$BsmtFullBath)] = 0
table(all$BsmtFullBath)
```

**BsmtHalfBath: Basement half bathrooms**

整数变量.
```{r}
all$BsmtHalfBath[is.na(all$BsmtHalfBath)] = 0
table(all$BsmtHalfBath)
```

**BsmtFinSF1: Type 1 finished square feet**

整数变量.
```{r}
all$BsmtFinSF1[is.na(all$BsmtFinSF1)] = 0
```

**BsmtFinSF2: Type 2 finished square feet**

整数变量.
```{r}
all$BsmtFinSF2[is.na(all$BsmtFinSF2)] = 0
```

**BsmtUnfSF: Unfinished square feet of basement area**

整数变量.
```{r}
all$BsmtUnfSF[is.na(all$BsmtUnfSF)] = 0
```

**TotalBsmtSF: Total square feet of basement area**

整数变量.

```{r}
all$TotalBsmtSF[is.na(all$TotalBsmtSF)] = 0
```

```{r}
BasementNacols = all %>%
    select(starts_with("Bs"), TotalBsmtSF) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
BasementNacols
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Masonry(墙体或地面贴面)变量

**Masonry veneer type 和 masonry veneer area**

```{r}
MasonryCols = all %>% 
    select(starts_with("Mas")) %>%
    head()
MasonryCols
```

* **检查Masonry变量缺失情况**

```{r}
MasonryNaCols = all %>%
    select(starts_with("Mas")) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = FALSE)
MasonryNaCols
```

* **分析缺失模式：**

```{r}
#check if the 23 houses with veneer area NA are also NA in the veneer type
length(which(is.na(all$MasVnrType) & is.na(all$MasVnrArea)))

#find the one that should have a MasVnrType
all[is.na(all$MasVnrType) & !is.na(all$MasVnrArea), c('MasVnrType', 'MasVnrArea')]
```

上面的分析得到，MasVnrType有24个缺失值，MasVnrArea有23个缺失值，并且有23个观测值在这两个变量中同时缺失，说明这23个房子是没有Marsonry的。而只有MasVnrType一个变量缺失的观测，下面将先对MasVnrType这个观测值填充进行(中位数填充)：

```{r}
#fix this veneer type by imputing the mode
all$MasVnrType[2611] <- names(sort(-table(all$MasVnrType)))[2] #taking the 2nd value as the 1st is 'none'
all[2611, c('MasVnrType', 'MasVnrArea')]
```

**Masonry veneer type：墙面或地面的贴面类型**

下面将会分析Masonry veneer type是否是有序变量.

       BrkCmn	Brick Common
       BrkFace	Brick Face
       CBlock	Cinder Block
       None	    None
       Stone	Stone

```{r}
all$MasVnrType[is.na(all$MasVnrType)] = 'None'

all[!is.na(all$SalePrice), ] %>% 
    group_by(MasVnrType) %>% 
    dplyr::summarise(median = median(SalePrice), counts = n()) %>% 
    arrange(median)
```

从上面的分析可以看出，BrkCmn和None类型对应的SalePrice中位数明显要低于BrkFace和Stone对应的SalePrice中位数，所以MasVnrType应该是一个有序类别型变量，通过下面的重新编码将MasVnrType转换为有序类别型变量。

```{r}
Masonry = c('None' = 0, 'BrkCmn' = 0, 'BrkFace' = 1, 'Stone' = 2)
all$MasVnrType = as.integer(revalue(all$MasVnrType, Masonry))
table(all$MasVnrType)
```

**MasVnrArea: 墙面或地面的贴面面积**

整数型变量.

```{r}
all$MasVnrArea[is.na(all$MasVnrArea)] = 0
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###MS Zoning

**MSZoning: 标识房子区域类别的一般变量**

* **检查MSZoning变量缺失情况**

```{r}
MSZoningNa = all %>%
    select(MSZoning) %>%
    is.na() %>%
    colSums() %>%
    sort(decreasing = TRUE)
MSZoningNa
```

类别型变量，转换为因子类型.

       A	Agriculture
       C	Commercial
       FV	Floating Village Residential
       I	Industrial
       RH	Residential High Density
       RL	Residential Low Density
       RP	Residential Low Density Park 
       RM	Residential Medium Density

```{r}
#imputing the mode
all$MSZoning[is.na(all$MSZoning)] = names(sort(-table(all$MSZoning)))[1]
all$MSZoning = as.factor(all$MSZoning)
table(all$MSZoning)
sum(table(all$MSZoning))
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Kitchen(厨房)变量

**厨房数质量和地面以上的厨房数量**

* **检查厨房变量的缺失情况**

```{r}
KitchenNaCols = all %>%
    select(starts_with("Kitchen")) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
KitchenNaCols
```

**Kitchen质量**

有一个缺失值并且为有序类别型变量.

       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
 
```{r, message=FALSE}
all$KitchenQual[is.na(all$KitchenQual)] = 'TA' #replace with most common value
all$KitchenQual = as.integer(revalue(all$KitchenQual, Qualities))
table(all$KitchenQual)
sum(table(all$KitchenQual))
```

**地面以上的厨房数量**

整数变量，没有缺失值.

```{r}
table(all$KitchenAbvGr)
sum(table(all$KitchenAbvGr))
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Utilities(公用事业)

* **检查Utilities的缺失情况**

```{r}
UtilitiesNa = all %>%
    select(Utilities) %>%
    is.na() %>%
    colSums()
UtilitiesNa
```


**Utilities: Type of utilities available**



2 NAs. Ordinal as additional utilities is better.

       AllPub	All public Utilities (E,G,W,& S)	
       NoSewr	Electricity, Gas, and Water (Septic Tank)
       NoSeWa	Electricity and Gas Only
       ELO	    Electricity only

However, the table below shows that only one house does not have all public utilities. This house is in the train set. Therefore, imputing 'AllPub' for the NAs means that all houses in the test set will have 'AllPub'. This makes the variable useless for prediction. Consequently, I will get rid of it.
这个变量应该是一个有序类别型变量，但是在无缺失的数据中仅有一个观测值不是AllPub，并且这个房子的观测值在训练数据中，并且这两个缺失值都在测试数据中，如果用AllPub来填充缺失值，那么这个变量将对模型预测变得没有任何用处，因此，删除这个变量。


```{r, message=FALSE}
table(all$Utilities)
kable(all[is.na(all$Utilities) | all$Utilities == 'NoSeWa', 1:9])
all$Utilities = NULL
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Home functionality

* **检查Functional变量的缺失情况**

```{r}
FunctionalNas = all %>%
    select(Functional) %>%
    is.na() %>%
    colSums()
FunctionalNas
```


**Functional: Home functionality**

该变量有2个缺失值，且为有序类别型变量.

       Typ	Typical Functionality
       Min1	Minor Deductions 1
       Min2	Minor Deductions 2
       Mod	Moderate Deductions
       Maj1	Major Deductions 1
       Maj2	Major Deductions 2
       Sev	Severely Damaged
       Sal	Salvage only


```{r, message=FALSE}
#impute mode for the 1 NA
all$Functional[is.na(all$Functional)] = names(sort(-table(all$Functional)))[1]

all$Functional = as.integer(revalue(all$Functional, c('Sal' = 0, 'Sev' = 1, 'Maj2' = 2, 'Maj1' = 3, 'Mod' = 4, 'Min2' = 5, 'Min1' = 6, 'Typ' = 7)))
table(all$Functional)
sum(table(all$Functional))
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Exterior variables

* **检查Exterior变量的缺失情况**

```{r}
ExteriorNaCols = all %>%
    select(starts_with("Exter")) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
ExteriorNaCols
```
 
**Exterior1st: 房子外部的覆盖物**

一个缺失值，类别型变量.

       AsbShng	Asbestos Shingles
       AsphShn	Asphalt Shingles
       BrkComm	Brick Common
       BrkFace	Brick Face
       CBlock	Cinder Block
       CemntBd	Cement Board
       HdBoard	Hard Board
       ImStucc	Imitation Stucco
       MetalSd	Metal Siding
       Other	Other
       Plywood	Plywood
       PreCast	PreCast	
       Stone	Stone
       Stucco	Stucco
       VinylSd	Vinyl Siding
       Wd Sdng	Wood Siding
       WdShing	Wood Shingles

```{r}
#imputing mode
all$Exterior1st[is.na(all$Exterior1st)] = names(sort(-table(all$Exterior1st)))[1]

all$Exterior1st = as.factor(all$Exterior1st)
table(all$Exterior1st)
sum(table(all$Exterior1st))
```

**Exterior2nd: 房子外部的第二层覆盖物**

一个缺失值，类别型变量.

       AsbShng	Asbestos Shingles
       AsphShn	Asphalt Shingles
       BrkComm	Brick Common
       BrkFace	Brick Face
       CBlock	Cinder Block
       CemntBd	Cement Board
       HdBoard	Hard Board
       ImStucc	Imitation Stucco
       MetalSd	Metal Siding
       Other	Other
       Plywood	Plywood
       PreCast	PreCast
       Stone	Stone
       Stucco	Stucco
       VinylSd	Vinyl Siding
       Wd Sdng	Wood Siding
       WdShing	Wood Shingles

```{r}
#imputing mode
all$Exterior2nd[is.na(all$Exterior2nd)] = names(sort(-table(all$Exterior2nd)))[1]

all$Exterior2nd = as.factor(all$Exterior2nd)
table(all$Exterior2nd)
sum(table(all$Exterior2nd))
```

**ExterQual: 房子覆盖物的质量** 

没有缺失值，有序类别型变量.

       Ex	Excellent
       Gd	Good
       TA	Average/Typical
       Fa	Fair
       Po	Poor
       
```{r}
all$ExterQual = as.integer(revalue(factor(all$ExterQual), Qualities))
table(all$ExterQual)
sum(table(all$ExterQual))
```

		
**ExterCond: 评估外部材料的现状**

没有缺失值，有序类别型变.

       Ex	Excellent
       Gd	Good
       TA	Average/Typical
       Fa	Fair
       Po	Poor

```{r}
all$ExterCond = as.integer(revalue(all$ExterCond, Qualities))
table(all$ExterCond)
sum(table(all$ExterCond))
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Electrical(电力系统)

* **检查Electrical变量缺失情况**

```{r}
ElectricalNas = all %>%
    select(Electrical) %>%
    is.na() %>%
    colSums()
ElectricalNas
```


**Electrical: 电力系统**

一个缺失值，类别型变量.

       SBrkr	Standard Circuit Breakers & Romex
       FuseA	Fuse Box over 60 AMP and all Romex wiring (Average)	
       FuseF	60 AMP Fuse Box and mostly Romex wiring (Fair)
       FuseP	60 AMP Fuse Box and mostly knob & tube wiring (poor)
       Mix	    Mixed

```{r}
#imputing mode
all$Electrical[is.na(all$Electrical)] = names(sort(-table(all$Electrical)))[1]

all$Electrical = as.factor(all$Electrical)
table(all$Electrical)
sum(table(all$Electrical))
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**

###Sale Type和Condition(交易类型和条件)

* **检查交易变量的缺失情况**

```{r}
SaleNaCols = all %>%
    select(SaleType, SaleCondition) %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
SaleNaCols
```


**SaleType: 交易类型**

没有缺失值，类别型变量.

       WD 	Warranty Deed - Conventional
       CWD	Warranty Deed - Cash
       VWD	Warranty Deed - VA Loan
       New	Home just constructed and sold
       COD	Court Officer Deed/Estate
       Con	Contract 15% Down payment regular terms
       ConLw	Contract Low Down payment and low interest
       ConLI	Contract Low Interest
       ConLD	Contract Low Down
       Oth	    Other

```{r}
#imputing mode
all$SaleType[is.na(all$SaleType)] = names(sort(-table(all$SaleType)))[1]

all$SaleType = as.factor(all$SaleType)
table(all$SaleType)
sum(table(all$SaleType))
```

**SaleCondition: 交易条件**

没有缺失值，类别型变量.

       Normal	Normal Sale
       Abnorml	Abnormal Sale -  trade, foreclosure, short sale
       AdjLand	Adjoining Land Purchase
       Alloca	Allocation - two linked properties with separate deeds, typically condo with a garage unit	
       Family	Sale between family members
       Partial	Home was not completed when last assessed (associated with New Homes)

```{r}
all$SaleCondition = as.factor(all$SaleCondition)
table(all$SaleCondition)
sum(table(all$SaleCondition))
```

**Please return to the 5.2 Tabs menu to select other (groups of) variables**


填充完所有的缺失之后，检查数据的缺失情况: 

```{r}
all %>%
    sapply(function(x) is.na(x)) %>%
    colSums() %>%
    sort(decreasing = TRUE)
```




##标签重编码、字符型变量转换为因子 {.tabset}

上面已经对所有的变量进行了缺失值填充，下面将对其余的没有缺失值的字符变量进行处理，比如：有序类别变量重编码，无序类别变量转换为因子类型：


```{r}
CharCols = names(all[, sapply(all, is.character)])
CharCols
cat('There are', length(CharCols), 'remaining columns with character values')
```

###Foundation

**Foundation: Type of foundation**

        BrkTil          Brick & Tile
        CBlock	        Cinder Block
        PConc	        Poured Contrete	
        Slab	        Slab
        Stone	        Stone
        Wood	        Wood

Foundation不是有序变量，只需要转换为因子类型：

```{r}
all$Foundation = as.factor(all$Foundation)
table(all$Foundation)
sum(table(all$Foundation))
```

**Please return to the 5.3 Tabs menu to select other (groups of) variables**

###Heating和airco

**(1)Heating: 取暖类型**
		
       Floor	Floor Furnace
       GasA	    Gas forced warm air furnace
       GasW	    Gas hot water or steam heat
       Grav	    Gravity furnace	
       OthW	    Hot water or steam heat other than gas
       Wall	    Wall furnace

Heating不是有序变量，只需将其转换为因子类型：

```{r}
all$Heating = as.factor(all$Heating)
table(all$Heating)
sum(table(all$Heating))
```

**(2)HeatingQC: 取暖的质量和条件**

       Ex	Excellent
       Gd	Good
       TA	Average/Typical
       Fa	Fair
       Po	Poor

HeatingQC是一个有序类别型变量，将其进行重编码：

```{r}
all$HeatingQC = as.integer(revalue(all$HeatingQC, Qualities))
table(all$HeatingQC)
sum(table(all$HeatingQC))
```

**(3)CentralAir: 是否由中央空调**

       N	No
       Y	Yes

CentraAir是类别型变量，但不是有序的，将其重编码为数字表示的因子类型：

```{r}
all$CentralAir = as.integer(revalue(all$CentralAir, c('N' = 0, 'Y' = 1)))
table(all$CentralAir)
sum(table(all$CentralAir))
```

**Please return to the 5.3 Tabs menu to select other (groups of) variables**
       
###Roof

**(1) RoofStyle: Type of roof**

       Flat	    Flat
       Gable	Gable
       Gambrel	Gabrel (Barn)
       Hip	    Hip
       Mansard	Mansard
       Shed	    Shed

RoofStyle不是有序变量，将其转换为因子类型即可：

```{r}
all$RoofStyle = as.factor(all$RoofStyle)
table(all$RoofStyle)
sum(table(all$RoofStyle))
```
		
**(2) RoofMatl: Roof material**

       ClyTile	Clay or Tile
       CompShg	Standard (Composite) Shingle
       Membran	Membrane
       Metal	Metal
       Roll	    Roll
       Tar&Grv	Gravel & Tar
       WdShake	Wood Shakes
       WdShngl	Wood Shingles

RoofMatl不是有序变量，将其转换为因子类型即可：

```{r}
all$RoofMatl = as.factor(all$RoofMatl)
table(all$RoofMatl)
sum(table(all$RoofMatl))
```

**Please return to the 5.3 Tabs menu to select other (groups of) variables**
       
###Land

**(1) LandContour: Flatness of the property**

       Lvl	Near Flat/Level	
       Bnk	Banked - Quick and significant rise from street grade to building
       HLS	Hillside - Significant slope from side to side
       Low	Depression

LandContour不是有序变量，将其转换为因子类型即可：

```{r}
all$LandContour = as.factor(all$LandContour)
table(all$LandContour)
sum(table(all$LandContour))
```
       
**(2) LandSlope: Slope of property**
		
       Gtl	Gentle slope
       Mod	Moderate Slope	
       Sev	Severe Slope

LandSlope是一个有序类别型变量，将其进行重编码：

```{r}
all$LandSlope = as.integer(revalue(all$LandSlope, c('Sev' = 0, 'Mod' = 1, 'Gtl' = 2)))
table(all$LandSlope)
sum(table(all$LandSlope))
```

**Please return to the 5.3 Tabs menu to select other (groups of) variables**

###Dwelling

**(1) BldgType: Type of dwelling**
		
       1Fam	    Single-family Detached	
       2FmCon	Two-family Conversion; originally built as one-family dwelling
       Duplx	Duplex
       TwnhsE	Townhouse End Unit
       TwnhsI	Townhouse Inside Unit

利用数据可视化来检查一下BldgType是否是类别型变量：

```{r}
ggplot(all[!is.na(all$SalePrice), ], mapping = aes(x = as.factor(BldgType), y = SalePrice)) +
        geom_bar(stat = 'summary', fun.y = "median") +
        scale_y_continuous(breaks = seq(0, 800000, by = 100000), labels = comma) +
        geom_label(stat = "count", mapping = aes(label = ..count.., y = ..count..))
```

从上面可以看出BldgType不是有序变量，所以只需将其转换为因子类型：

```{r}
#No ordinality, so converting into factors
all$BldgType <- as.factor(all$BldgType)
table(all$BldgType)
sum(table(all$BldgType))
```
	
**(2) HouseStyle: Style of dwelling**
	
       1Story	One story
       1.5Fin	One and one-half story: 2nd level finished
       1.5Unf	One and one-half story: 2nd level unfinished
       2Story	Two story
       2.5Fin	Two and one-half story: 2nd level finished
       2.5Unf	Two and one-half story: 2nd level unfinished
       SFoyer	Split Foyer
       SLvl	Split Level

HouseStyle不是有序变量，所以只需将其转换为因子类型：

```{r}
all$HouseStyle <- as.factor(all$HouseStyle)
table(all$HouseStyle)
sum(table(all$HouseStyle))
```

**Please return to the 5.3 Tabs menu to select other (groups of) variables**

###Neighborhood and Conditions

**(1) Neighborhood: Physical locations within Ames city limits**

Note: as the number of levels is really high, I will look into binning later on.

       Blmngtn	Bloomington Heights
       Blueste	Bluestem
       BrDale	Briardale
       BrkSide	Brookside
       ClearCr	Clear Creek
       CollgCr	College Creek
       Crawfor	Crawford
       Edwards	Edwards
       Gilbert	Gilbert
       IDOTRR	Iowa DOT and Rail Road
       MeadowV	Meadow Village
       Mitchel	Mitchell
       Names	North Ames
       NoRidge	Northridge
       NPkVill	Northpark Villa
       NridgHt	Northridge Heights
       NWAmes	Northwest Ames
       OldTown	Old Town
       SWISU	South & West of Iowa State University
       Sawyer	Sawyer
       SawyerW	Sawyer West
       Somerst	Somerset
       StoneBr	Stone Brook
       Timber	Timberland
       Veenker	Veenker

Neighborhood不是有序变量，所以只需将其转换为因子类型：

```{r}
all$Neighborhood = as.factor(all$Neighborhood)
table(all$Neighborhood)
sum(table(all$Neighborhood))
```

**(2) Condition1: Proximity to various conditions**
	
       Artery	Adjacent to arterial street
       Feedr	Adjacent to feeder street	
       Norm	Normal	
       RRNn	Within 200' of North-South Railroad
       RRAn	Adjacent to North-South Railroad
       PosN	Near positive off-site feature--park, greenbelt, etc.
       PosA	Adjacent to postive off-site feature
       RRNe	Within 200' of East-West Railroad
       RRAe	Adjacent to East-West Railroad

Condition1不是有序变量，所以只需将其转换为因子类型：

```{r}
all$Condition1 = as.factor(all$Condition1)
table(all$Condition1)
sum(table(all$Condition1))
```
	
**(3) Condition2: Proximity to various conditions (if more than one is present)**
		
       Artery	Adjacent to arterial street
       Feedr	Adjacent to feeder street	
       Norm	Normal	
       RRNn	Within 200' of North-South Railroad
       RRAn	Adjacent to North-South Railroad
       PosN	Near positive off-site feature--park, greenbelt, etc.
       PosA	Adjacent to postive off-site feature
       RRNe	Within 200' of East-West Railroad
       RRAe	Adjacent to East-West Railroad

Condition2不是有序变量，所以只需将其转换为因子类型：

```{r}
all$Condition2 <- as.factor(all$Condition2)
table(all$Condition2)
sum(table(all$Condition2))
```

**Please return to the 5.3 Tabs menu to select other (groups of) variables**

###Pavement of Street & Driveway

**(1) Street: Type of road access to property**

       Grvl	Gravel	
       Pave	Paved

Street是有序变量，将其重编码为有序类别型变量：

```{r}
all$Street = as.integer(revalue(all$Street, c('Grvl' = 0, 'Pave' = 1)))
table(all$Street)
sum(table(all$Street))
```
       
**(2) PavedDrive: Paved driveway**

       Y	Paved 
       P	Partial Pavement
       N	Dirt/Gravel

PavedDrive是有序变量，将其重编码为有序类别型变量：

```{r}
all$PavedDrive = as.integer(revalue(all$PavedDrive, c('N' = 0, 'P' = 1, 'Y' = 2)))
table(all$PavedDrive)
sum(table(all$PavedDrive))
```

**Please return to the 5.3 Tabs menu to select other (groups of) variables**


##将一些数值型变量转换为因子类型

###Year和Month Sold
> * YearBuilt是一个年份数值，虽然他作为有序变量是有意义的，比如：老房子比新房子便宜，但是，也会有一些特殊情况，比如2009年的经济危机直接造成房子的销售价格远低于2007年的房子的价格(见下面的数据可视化)，所以，这里不应该将YearBuilt当做一个有序型变量来进行建模，需要将其转换为因子类型，但是下面的特征工程中将要构造一个房子年龄的变量，因此，不进行转换；
> * Month Sold也是一个整数型月份变量，虽然房子销售也有淡旺季，但是这只表明是季节性因素在起作用(见数据可视化)，月份的顺序对于房子的价格是没有直接影响的，所以这里将其转换为因子变量。

```{r}
all$MoSold = as.factor(all$MoSold)
```

```{r}
ys = ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = as.factor(YrSold), y = SalePrice)) +
    geom_bar(stat = "summary", fun.y = "median") +
    scale_y_continuous(breaks = seq(0, 800000, by = 25000), labels = comma) +
    geom_label(stat = "count", mapping = aes(label = ..count.., y = ..count..)) +
    coord_cartesian(ylim = c(0, 200000)) + 
    geom_hline(yintercept = median(all$SalePrice, na.rm = TRUE), linetype = "dashed", col = "red")
ms = ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = MoSold, y = SalePrice)) +
    geom_bar(stat = "summary", fun.y = "median") +
    scale_y_continuous(breaks = seq(0, 800000, by = 25000), labels = comma) +
    geom_label(stat = "count", mapping = aes(label = ..count.., y = ..count..)) +
    coord_cartesian(ylim = c(0, 200000)) +
    geom_hline(yintercept = median(all$SalePrice, na.rm = TRUE), linetype = "dashed", color = "red")
grid.arrange(ys, ms, widths = c(1, 2))
```

### MSSubClass

MSSubClass确定销售涉及的住宅类型，应该是一个类别型变量：

```{r}
str(all$MSSubClass)
all$MSSubClass = as.factor(all$MSSubClass)
table(all$MSSubClass)
all$MSSubClass = revalue(all$MSSubClass, c('20' = '1 story 1946+', 
                                           '30' = '1 story 1945-', 
                                           '40' = '1 story unf attic', 
                                           '45' = '1,5 story unf', 
                                           '50' = '1,5 story fin', 
                                           '60' = '2 story 1946+', 
                                           '70' = '2 story 1945-', 
                                           '75' = '2,5 story all ages', 
                                           '80' = 'split/multi level', 
                                           '85' = 'split foyer', 
                                           '90' = 'duplex all style/age', 
                                           '120' = '1 story PUD 1946+', 
                                           '150' = '1,5 story PUD all', 
                                           '160' = '2 story PUD 1946+', 
                                           '180' = 'PUD multilevel', 
                                           '190' = '2 family conversion'))
table(all$MSSubClass)
```





#重要变量的可视化

##数值型变量的相关性可视化

```{r, warning = FALSE}
numericVars = which(sapply(all, is.numeric))
numericVars
factorVars = which(sapply(all, is.factor))
factorVars
cat('有', length(numericVars), '个数值型变量, 有', length(factorVars), '个类别型变量.')
```

```{r}
all_numVar = all[, numericVars]
cor_numVar = cor(all_numVar, use = 'pairwise.complete.obs')
cor_sorted = as.matrix(sort(cor_numVar[, 'SalePrice'], decreasing = TRUE))
CorHigh = names(which(apply(cor_sorted, 1, function(x) abs(x) > 0.5)))
cor_numVar = cor_numVar[CorHigh, CorHigh]
corrplot.mixed(cor_numVar, tl.col = "black", tl.pos = "lt", tl.cex = 0.7, cl.cex = 0.7, number.cex = 0.7)
```


##利用一个快速的随机森林模型分析变量的重要性


```{r}
set.seed(2018)
quick_RF = randomForest(x = all[1:1460, -79], y = all$SalePrice[1:1460], ntree = 100, importance = TRUE)
imp_RF = importance(quick_RF)
imp_DF = data.frame(Variables = row.names(imp_RF), MSE = imp_RF[, 1])
imp_DF = imp_DF[order(imp_DF$MSE, decreasing = TRUE), ]

ggplot(data = imp_DF[1:20, ], mapping = aes(x = reorder(Variables, MSE), y = MSE, fill = MSE)) +
    geom_bar(stat = 'identity') +
    labs(x = "Variables", y = "% increase MSE if variable is randomly permuted") +
    coord_flip() +
    theme(legend.position = "none")
```

上面变量重要性分析中，可以看出，在前20个重要的变量中，只有三个类别型变量：Neighborhood, MSSubClass, GarageType.

##GrLivArea变量和与其相关的面积(平方英尺)变量分布可视化

* GrLivArea：地面以上生活面积
* TotRmsAbvGrd：地面以上房间数
* X1stFlrSF: 一层居住面积
* X2ndFlrSF：二层居住面积
* TotalBsmtSF：地下室面积
* LotArea：Square feet lot
* LotFrontage：Linear feet lot frontage
* LowQualFinSF：一层和二层的低质量面积


```{r}
all %>%
    select(GrLivArea, TotRmsAbvGrd, "1stFlrSF", "2ndFlrSF", TotalBsmtSF, LotArea, LotFrontage, LowQualFinSF) %>%
    head()
s1 = ggplot(data = all, mapping = aes(x = GrLivArea)) +
    geom_density() +
    labs(x = "Square feet living area")
s2 = ggplot(data = all, mapping = aes(x = as.factor(TotRmsAbvGrd))) +
    geom_histogram(stat = "count") +
    labs(x = "Rooms above Ground")
s22 = ggplot(data = all, mapping = aes(x = as.factor(TotRmsAbvGrd))) +
    geom_bar(stat = "count") +
    labs(x = "Rooms above Ground")
s3 = ggplot(data = all, mapping = aes(x = "1stFlrSF")) +
    geom_density() +
    labs(x = "Square feet first floor")
s4 = ggplot(data = all, mapping = aes(x = "2ndFlrSF")) +
    geom_density() +
    labs(x = "Square feet second floor")
s5 = ggplot(data = all, mapping = aes(x = TotalBsmtSF)) +
    geom_density() +
    labs(x = "Square feet basement")
s6 = ggplot(data = all[all$LotArea < 100000, ], mapping = aes(x = LotArea)) +
    geom_density() +
    labs(x = "Square feet lot")
s7 = ggplot(data = all, mapping = aes(x = LotFrontage)) +
    geom_density() +
    labs(x = "Linear feet lot frontage")
s8 = ggplot(data = all, mapping = aes(x = LowQualFinSF)) +
    geom_histogram() +
    labs(x = "Low quality square feet 1st & 2nd")
layout = matrix(c(1, 2, 5, 3, 4, 8, 6, 7), 4, 2, byrow = TRUE)
multiplot(s1, s2, s3, s4, s5, s6, s7, s8, layout = layout)
```


```{r}
cor(all$GrLivArea, (all$`1stFlrSF` + all$`2ndFlrSF` + all$LowQualFinSF))
all %>%
    filter(LowQualFinSF > 0) %>%
    select(GrLivArea, `1stFlrSF`, `2ndFlrSF`, LowQualFinSF)
```

可以发下GrLivArea是1stFlrSF, 2ndFlrSF, LowQualFinSF这三个变量的和。

##最重要的类别型变量Neighborhood

```{r, warning=FALSE}
n1 = ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = Neighborhood, y = SalePrice)) +
    geom_bar(stat = "summary", fun.y = "median") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma) +
    geom_label(stat = "count", mapping = aes(label = ..count.., y = ..count..), size = 3) +
    geom_hline(yintercept = median(all$SalePrice, na.rm = TRUE), linetype = "dashed", color = "red")

n2 = ggplot(data = all, mapping = aes(x = Neighborhood)) +
    geom_histogram(stat = "count") +
    geom_label(stat = "count", mapping = aes(label = ..count.., y = ..count..), size = 3) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
grid.arrange(n1, n2)
```

##房子的总体质量，以及和质量相关的变量


和房子质量相关的变量：

* OverallQual
* ExterQual
* BsmtQual
* KitchenQual
* GarageQual
* FireplaceQu
* PoolQC


```{r, warning=FALSE}
q1 = ggplot(data = all, aes(x = as.factor(OverallQual))) +
        geom_histogram(stat = 'count')
q2 = ggplot(data = all, aes(x = as.factor(ExterQual))) +
        geom_histogram(stat = 'count')
q3 = ggplot(data = all, aes(x = as.factor(BsmtQual))) +
        geom_histogram(stat = 'count')
q4 = ggplot(data = all, aes(x = as.factor(KitchenQual))) +
        geom_histogram(stat = 'count')
q5 = ggplot(data = all, aes(x = as.factor(GarageQual))) +
        geom_histogram(stat = 'count')
q6 = ggplot(data = all, aes(x = as.factor(FireplaceQu))) +
        geom_histogram(stat = 'count')
q7 = ggplot(data = all, aes(x = as.factor(PoolQC))) +
        geom_histogram(stat = 'count')

layout = matrix(c(1, 2, 8, 3, 4, 8, 5, 6, 7), 3, 3,byrow = TRUE)
multiplot(q1, q2, q3, q4, q5, q6, q7, layout = layout)
```

##MSSubClass

```{r, warning=FALSE}
ms1 <- ggplot(all[!is.na(all$SalePrice),], aes(x=MSSubClass, y=SalePrice)) +
        geom_bar(stat='summary', fun.y = "median", fill='blue') +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        scale_y_continuous(breaks= seq(0, 800000, by=50000), labels = comma) +
        geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3) +
        geom_hline(yintercept=163000, linetype="dashed", color = "red") #dashed line is median SalePrice
ms2 <- ggplot(data=all, aes(x=MSSubClass)) +
        geom_histogram(stat='count')+
        geom_label(stat = "count", aes(label = ..count.., y = ..count..), size=3) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
grid.arrange(ms1, ms2)
```

##车库变量

```{r, warning=FALSE}
g1 <- ggplot(data=all[all$GarageCars !=0,], aes(x=GarageYrBlt)) +
        geom_histogram()
g2 <- ggplot(data=all, aes(x=as.factor(GarageCars))) +
        geom_histogram(stat='count')
g3 <- ggplot(data= all, aes(x=GarageArea)) +
        geom_density()
g4 <- ggplot(data=all, aes(x=as.factor(GarageCond))) +
        geom_histogram(stat='count')
g5 <- ggplot(data=all, aes(x=GarageType)) +
        geom_histogram(stat='count')
g6 <- ggplot(data=all, aes(x=as.factor(GarageQual))) +
        geom_histogram(stat='count')
g7 <- ggplot(data=all, aes(x=as.factor(GarageFinish))) +
        geom_histogram(stat='count')

layout <- matrix(c(1,5,5,2,3,8,6,4,7),3,3,byrow=TRUE)
multiplot(g1, g2, g3, g4, g5, g6, g7, layout=layout)
```


##地下室变量

```{r, warning=FALSE}
b1 <- ggplot(data=all, aes(x=BsmtFinSF1)) +
        geom_histogram() + labs(x='Type 1 finished square feet')
b2 <- ggplot(data=all, aes(x=BsmtFinSF2)) +
        geom_histogram()+ labs(x='Type 2 finished square feet')
b3 <- ggplot(data=all, aes(x=BsmtUnfSF)) +
        geom_histogram()+ labs(x='Unfinished square feet')
b4 <- ggplot(data=all, aes(x=as.factor(BsmtFinType1))) +
        geom_histogram(stat='count')+ labs(x='Rating of Type 1 finished area')
b5 <- ggplot(data=all, aes(x=as.factor(BsmtFinType2))) +
        geom_histogram(stat='count')+ labs(x='Rating of Type 2 finished area')
b6 <- ggplot(data=all, aes(x=as.factor(BsmtQual))) +
        geom_histogram(stat='count')+ labs(x='Height of the basement')
b7 <- ggplot(data=all, aes(x=as.factor(BsmtCond))) +
        geom_histogram(stat='count')+ labs(x='Rating of general condition')
b8 <- ggplot(data=all, aes(x=as.factor(BsmtExposure))) +
        geom_histogram(stat='count')+ labs(x='Walkout or garden level walls')

layout <- matrix(c(1,2,3,4,5,9,6,7,8),3,3,byrow=TRUE)
multiplot(b1, b2, b3, b4, b5, b6, b7, b8, layout=layout)
```


#特征工程

##浴室总数量变量

共有4个浴室变量

```{r}
bathCols = all %>%
    select(ends_with("Bath")) %>%
    head()
bathCols
```

```{r}
cor_numVar = cor(all[, c(names(bathCols), "SalePrice")], use = 'pairwise.complete.obs')
cor_sorted = as.matrix(sort(cor_numVar[, 'SalePrice'], decreasing = TRUE))
CorHigh = names(which(apply(cor_sorted, 1, function(x) abs(x) > 0)))
cor_numVar = cor_numVar[CorHigh, CorHigh]
corrplot.mixed(cor_numVar, tl.col = "black", tl.pos = "lt", tl.cex = 0.7, cl.cex = 0.7, number.cex = 0.7)
```
从上面的分析看出，单个浴室变量与SalePrice的相关性最大为0.56，其余变量与SalePrice的相关性都很小，所以创建一个浴室总数量变量，来总体描述浴室的数量，并检测它与SalePrice的相关性，可以看到新建的浴室总数量明显可以很好地描述浴室对于SalePrice的影响：

```{r}
all$TotBathrooms = all$FullBath + (all$HalfBath * 0.5) + all$BsmtFullBath + (all$BsmtHalfBath * 0.5)
cor(all[, c("TotBathrooms", "SalePrice")], use = 'pairwise.complete.obs')
```


```{r}
tb1 = ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = as.factor(TotBathrooms), y = SalePrice)) +
    geom_point(col = "blue") +
    geom_smooth(method = "lm", se = FALSE, color = "black", mapping = aes(group = 1)) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), label = comma)
tb2 = ggplot(data = all, mapping = aes(x = as.factor(TotBathrooms))) +
    geom_histogram(stat = "count")
grid.arrange(tb1, tb2)
```


##新建HouseAge(房子年龄)变量，IsNew(是否为新房子)变量


```{r}
all %>% 
    select(starts_with("Year"), YrSold) %>%
    head()
```


有三个变量和房子的年龄有关，YearBlt, YearRemodAdd, YearSold：

* YearBuilt:房子建造的年份
* YearRemodAdd：房子翻新的年份
* YrSold：房子出售的年份

下面将基于这三个变量创建两个变量：

* 房子是否进行过翻新
* 房子是否是新房子(如果房子的建造年份与房子的出售年份相同则认为是新房子)
* 房子的年龄(房子的出售年份-房子的翻新年份)


```{r}
all$Remod = ifelse(all$YearBuilt == all$YearRemodAdd, 0, 1)
all$Age = as.numeric(all$YrSold) - all$YearRemodAdd
all$IsNew = ifelse(all$YrSold == all$YearBuilt, 1, 0)
```


* Age

```{r}
ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = Age, y = SalePrice)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, color = "darkred", mapping = aes(group = 1)) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma)
cor(all$SalePrice[!is.na(all$SalePrice)], all$Age[!is.na(all$SalePrice)])
```

从上面的分析可以看出，Age变量和SalePrice有负的相关关系，但是相关性不是特别强。

* Remod

```{r}
ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = as.factor(Remod), y = SalePrice)) +
    geom_bar(stat = "summary", fun.y = "median") +
    geom_label(stat = "count", aes(label = ..count.., y = ..count..), size = 6) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma) +
    theme_grey(base_size = 18) +
    geom_hline(yintercept = 163000, linetype = "dashed")
```

分析得出，进行过翻修的房子的价格相比于没有进行过翻修的房子价格要低。

* IsNew

```{r}
table(all$IsNew)
```

```{r}
ggplot(all[!is.na(all$SalePrice), ], mapping = aes(x = as.factor(IsNew), y = SalePrice)) +
        geom_bar(stat = 'summary', fun.y = "median", fill = 'blue') +
        geom_label(stat = "count", aes(label = ..count.., y = ..count..), size = 6) +
        scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma) +
        theme_grey(base_size = 18) +
        geom_hline(yintercept = 163000, linetype = "dashed")
```

从上面的分析可以看出，新房子要明显比老房子要贵。

##对Neighborhood变量进行分箱

```{r}
nb1 = ggplot(data = all[!is.na(all$SalePrice), ], 
             mapping = aes(x = reorder(Neighborhood, SalePrice, FUN = median), y = SalePrice)) +
    geom_bar(stat = "summary", fun.y = "median", fill = "blue") +
    labs(x = "Neighborhood", y = "Median SalePrice") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma) +
    geom_label(stat = "count", mapping = aes(label = ..count.., y = ..count..), size = 3) +
    geom_hline(yintercept = 163000, linetype = "dashed", color = "red")

nb2 = ggplot(data = all[!is.na(all$SalePrice), ], 
             mapping = aes(x = reorder(Neighborhood, SalePrice, FUN = mean), y = SalePrice)) +
    geom_bar(stat = "summary", fun.y = "mean", fill = "blue") +
    labs(x = "Neighborhood", y = "Median SalePrice") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma) +
    geom_label(stat = "count", mapping = aes(label = ..count.., y = ..count..), size = 3) +
    geom_hline(yintercept = 163000, linetype = "dashed", color = "red")


grid.arrange(nb1, nb2)
```


从上面的分析可以看出，有三种Neighborhood对应的房子价格明显高于其他的Neighborhood，也有三种Neighborhood对应的房子价格明显低于其他的Neighborhood，所以讲Neighborhood重新进行编码：

```{r}
all$NeighRich[all$Neighborhood %in% c("StoneBr", "NridgHt", "NoRidge")] = 2
all$NeighRich[!all$Neighborhood %in% c("MeadowV", "IDOTRR", "BrDale", "StoneBr", "NridgHt", "NoRidge")] = 1

all$NeighRich[all$Neighborhood %in% c("MeadowV", "IDOTRR", "BrDale")] = 0 

table(all$NeighRich)
```

##新建总面积

对买房子的人来说非常看重房子的总面积，所以新建一个将地下和地上面积加总的面基变量：

```{r}
all$TotalSqFeet = all$GrLivArea + all$TotalBsmtSF
```

```{r}
ggplot(data = all[!is.na(all$SalePrice), ], 
       mapping = aes(x = TotalSqFeet, y = SalePrice)) +
    geom_point(col = "blue") +
    geom_smooth(method = "lm", se = FALSE, colour = "black", mapping = aes(group = 1)) +
    geom_text_repel(mapping = aes(label = ifelse(all$GrLivArea[!is.na(all$SalePrice)] > 4500, rownames(all), '')))
```

```{r}
cor(all$SalePrice, all$TotalSqFeet, use = "pairwise.complete.obs")
```
从上面的分析看出，新建的总面积变量和SalePrice有很强的相关关系，但是从两个变量的散点图中可以看出，有两个特别明显的异常值存在，下面给出去除掉这两个异常值后两个变量的相关关系：

```{r}
cor(all$SalePrice[-c(524, 1299)], all$TotalSqFeet[-c(524, 1299)], use = "pairwise.complete.obs")
```


##合并阳台(门廊)变量

下面是与阳台有关的变量：

* WoodDeckSF: Wood deck area in square feet
* OpenPorchSF: Open porch area in square feet
* EnclosedPorch: Enclosed porch area in square feet
* 3SsnPorch: Three season porch area in square feet
* ScreenPorch: Screen porch area in square feet

阳台或者门廊是房子处于顶部遮蔽的地方，而这里的WoodDeckSF是没有遮蔽的场所，所以这里仅考虑其他四个变量：

```{r}
all$TotalProchSF = all$OpenPorchSF + all$EnclosedPorch + all$`3SsnPorch` + all$ScreenPorch
```

```{r}
cor(all$SalePrice, all$TotalProchSF, use = "pairwise.complete.obs")
```

```{r}
ggplot(data = all[!is.na(all$SalePrice), ], mapping = aes(x = TotalProchSF, y = SalePrice)) +
    geom_point() +
    geom_smooth(method = "lm", se = FALSE, colour = "darkred", mapping = aes(group = 1)) +
    scale_y_continuous(breaks = seq(0, 800000, by = 50000), labels = comma)
```



#将数据预处理为建模可用的数据类型和格式

##删除相关性强的预测变量

```{r}
all_numVar = all[, numericVars]
cor_numVar = cor(all_numVar, use = 'pairwise.complete.obs')
cor_sorted = as.matrix(sort(abs(cor_numVar[, 'SalePrice']), decreasing = TRUE))
cor_sorted
CorHigh = names(which(apply(cor_sorted, 1, function(x) abs(x) > 0.5)))
cor_numVar = cor_numVar[CorHigh, CorHigh]
corrplot.mixed(cor_numVar, tl.col = "black", tl.pos = "lt", tl.cex = 0.7, cl.cex = 0.7, number.cex = 0.7)
```

首先，删除两个相关变量中与SalePrice相关性更弱的那一个变量：

```{r}
dim(all)
dropVars = c("YearRemodAdd", "GarageYrBlt", "GarageArea", "GarageCond", "TotalBsmtSF", "TotalRmsAbvGrd", "BsmtFinSF1")
all = all[, !names(all) %in% dropVars]
dim(all)
```

##删除异常值

删除两个房子面积很大而房子的价格很小的房子的观测值：

```{r}
all = all[- c(524, 1299), ]
```

##对预测变量进行预处理

* 对数值型变量(非经过重编码的变量)进行标准化、中心化
* 对类别型变量重编码为哑变量(dummy variable)

```{r}
numericVarNames = numericVarNames[!(numericVarNames %in% c("MSSubClass", "MoSold", "YrSold", "SalePrice", "OverallQual", "OverallCond"))]
numericVarNames = append(numericVarNames, c("Age", "TotalPorchSF", "TotBathrooms", "TotalSqFeet"))
DFnumeric = all[, names(all) %in% numericVarNames]
DFfactors = all[, !names(all) %in% numericVarNames]
DFfactors = DFfactors[, names(DFfactors) != "SalePrice"]
cat("有", length(DFnumeric), "个数值型变量; 有", length(DFfactors), "个因子型变量.")
```


###数值型变量的偏度和正态性

* **偏度**

偏度一般度量一个分布的对称性，对称分布的偏度为0，因此，一个正态分布的偏度为0。根据经验，一个分布如果是对称分布或接近对称分布，则它的偏度在[-1, 1]的范围内。所以，为了修正预测变量的偏度，将所有偏度的绝对值大于0.8的数值型变量取对数(实际上是log(x + 1)，防止变量观测值为0):

```{r}
ncol(DFnumeric)
for(i in 1:ncol(DFnumeric)) {
     if (abs(skew(DFnumeric[, i])) > 0.8) {
         DFnumeric[, i] = log(DFnumeric[, i] + 1)
     }
}
```


* **规范化**

```{r}
PreNum = preProcess(DFnumeric, method = c("center", "scale"))
print(PreNum)
DFnorm = predict(PreNum, DFnumeric)
dim(DFnorm)
```

### 将类别型变量转换为哑变量

```{r}
DFdummies = as.data.frame(model.matrix(~.-1, DFfactors))
dim(DFdummies)
```


###删除在训练数据集或测试数据集中只有少量或没有观测值的水平

```{r}
ZerocolTest = which(colSums(DFdummies[(nrow(all[is.na(all$SalePrice), ]) + 1):nrow(all), ]) == 0)
colnames(DFdummies[ZerocolTest])
DFdummies = DFdummies[, -ZerocolTest]

ZerocolTrain = which(colSums(DFdummies[1:nrow(all[is.na(all$SalePrice), ]), ]) == 0)
colnames(DFdummies[ZerocolTrain])
DFdummies = DFdummies[, -ZerocolTrain]

fewOnes = which(colSums(DFdummies[1:nrow(all[!is.na(all$SalePrice), ]), ]) < 10)
colnames(DFdummies[fewOnes])
DFdummies <- DFdummies[,-fewOnes]
dim(DFdummies)
```

```{r}
combined <- cbind(DFnorm, DFdummies)
```


##对响应变量SalePrice偏度进行处理

* SalePrice正态性检验

```{r}
skew(all$SalePrice)
qqnorm(all$SalePrice)
qqline(all$SalePrice)
```

* SalePrice正态性转换

```{r}
all$SalePrice = log(all$SalePrice + 1)
skew(all$SalePrice)
qqnorm(all$SalePrice)
# qqline(all$SalePrice)
```

##将All分割为训练数据集和验证数据集

```{r}
train1 = combined[!is.na(all$SalePrice), ]
dim(train1)
test1 = combined[is.na(all$SalePrice), ]
dim(test1)
```

#利用Lasso和XGBoost算法建模

## Ridge Regression

## Elastic Net

##Lasso Regression

```{r, eval=FALSE}
set.seed(27042018)
my_control = trainControl(method = "cv", number = 5)
lassoGrid = expand.grid(alpha = 1, 
                        lambda = seq(0.001, 0.1, by = 0.0005))
lasso_mod = train(x = train1, y = all$SalePrice[!is.na(all$SalePrice)], 
                  method = "glmnet", 
                  trControl = my_control, 
                  tuneGrid = lassoGrid)
lasso_mod$bestTune
```

##XGBoost

```{r, eval=F}
my_control = trainControl(method = "cv", number = 5)
xgb_grid = expand.grid(
    nround = 1000,
    eta = c(0.1, 0.05, 0.01),
    max_depth = c(2, 3, 4, 5, 6),
    gamma = 0,
    colsample_bytree = 1,
    minchild_weight = c(1, 2, 3, 4, 5),
    subsample = 1
)
xgb_caret = train(x = train1, 
                  y = all$SalePrice[!is.na(all$SalePrice)], 
                  method = 'xgbTree', 
                  trControl = my_control, 
                  tuneGrid = xgb_grid)
xgb_caret$bestTune
```

```{r, eval = F}
label_train = all$SalePrice[!is.na(all$SalePrice)]
dtrain = xgb.DMatrix(data = as.matrix(train1), label = label_train)
dtest = xgb.DMatrix(data = as.matrix(test1))

default_param = list(objective = 'reg:linear',
                     booster = "gbtree",
                     eta = 0.05,
                     gamma = 0,
                     max_depth = 3,
                     min_child_weight = 4,
                     subsample = 1,
                     colsample_bytree = 1
)

#利用交叉验证确定训练的轮数
xgbcv = xgb.cv(params = default_param, data = dtrain,
               nrounds = 500,
               nfold = 5,
               showsd = TRUE,
               stratified = TRUE,
               print_every_n = 40,
               early_stopping_rounds = 10,
               maximize = FALSE)
```

```{r, eval = F}
xgb_mod = xgb.train(data = dtrain, params = default_param, nrounds = 454)
XGBpred = predict(xgb_mod, dtest)
predictions_XGB = exp(XGBpred)
head(predictions_XGB)
```

```{r, eval=F}
library(Ckmeans.1d.dp)
mat = xgb.importance(feature_names = colnames(train1), model = xgb_mod)
xgb.ggplot.importance(importance_matrix = mat[1:20], rel_to_first = TRUE)

```


##平均预测值

```{r, eval=F}
sub_avg = data.frame(Id = test_labels, SalePrice = (predictions_XGB + 2 * predictions_lasso) / 3)
head(sub_avg)
write.csv(sub_avg, file = 'average.csv', row.names = FALSE)
```
